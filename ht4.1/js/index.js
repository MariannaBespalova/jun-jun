let a = false && true || true; //true, т.к. && выше приоритет, возвращает false, дальше false || true вернет true
let b = false && (true || true); // false, вначале выражение в скобках даст true, затем false && true вернет false
let c = +'40' + +'2';//42, т.к. унарнвый плюс перед '40' и '2' преобразует их в числа, затем сложение 
let d = '2' + 3 ** 2;// "29", т.к. 3**2 вернет 9, затем конкатенация строки и числа вернет строку 29
let e = 3 ** 2 / 3;//3, т.к. 3**2 будет 9, 9/3 будет 3
let f = 3 ** (9 / 3);//27, т.к. 9/3 будет 3, 3**3 будет 27
let g = '10' + (5 === 6);//"10false", т.к.(5 === 6) будет false, а конкатенация '10' и false дает строку "10false"
let k = '10' - 5 === 6; //false, '10'-5 будет 5, a 5 не равно 6
let l = undefined + 1;//NaN, т.к. undefined при преобразовании в число будет NaN, а любая манипуляция с NaN дает NaN
let m = (+null == false) < 1;//false, т.к. унарный плюс перед null дает 0, при не строгом сравнении 0 и false будет true.  Сравнивая true < 1 будет false, т.к. произойдет неявное преобразование к числу, а 1 < 1 вернет false
let n = (+null == false) < 1 ** 5;//false, т.к. унарный плюс перед null дает 0, при не строгом сравнении 0 и false будет true, a 1 ** 5 равно 1. Сравнивая true < 1 будет false, т.к. произойдет неявное преобразование к числу, а 1 < 1 даст false
let number = 5;
2 * ++number;//12
2 * number--;//12
console.log(number);//5

